{"ast":null,"code":"import { extent, nice, thresholdSturges, ticks } from \"d3-array\";\nimport { slice } from \"./array.js\";\nimport ascending from \"./ascending.js\";\nimport area from \"./area.js\";\nimport constant from \"./constant.js\";\nimport contains from \"./contains.js\";\nimport noop from \"./noop.js\";\nvar cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];\nexport default function () {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values); // Convert number of thresholds into uniform thresholds.\n\n    if (!Array.isArray(tz)) {\n      const e = extent(values, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n\n      while (tz[tz.length - 1] >= e[1]) tz.pop();\n\n      while (tz[1] < e[0]) tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(value => contour(values, value));\n  } // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n\n\n  function contour(values, value) {\n    const v = value == null ? NaN : +value;\n    if (isNaN(v)) throw new Error(`invalid value: ${value}`);\n    var polygons = [],\n        holes = [];\n    isorings(values, v, function (ring) {\n      smooth(ring, values, v);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(function (hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  } // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n\n\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n        fragmentByEnd = new Array(),\n        x,\n        y,\n        t0,\n        t1,\n        t2,\n        t3; // Special case for the first row (y = -1, t2 = t3 = 0).\n\n    x = y = -1;\n    t1 = above(values[0], value);\n    cases[t1 << 1].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t0 = t1, t1 = above(values[x + 1], value);\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n\n    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.\n\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = above(values[y * dx + dx], value);\n      t2 = above(values[y * dx], value);\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n\n      while (++x < dx - 1) {\n        t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);\n        t3 = t2, t2 = above(values[y * dx + x + 1], value);\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n\n      cases[t1 | t2 << 3].forEach(stitch);\n    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n\n\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t3 = t2, t2 = above(values[y * dx + x + 1], value);\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f,\n          g;\n\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function (point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v1 = valid(values[yt * dx + xt]);\n\n      if (x > 0 && x < dx && xt === x) {\n        point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);\n      }\n\n      if (y > 0 && y < dy && yt === y) {\n        point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = Math.floor(_[0]),\n        _1 = Math.floor(_[1]);\n\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function (_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n} // When computing the extent, ignore infinite values (as well as invalid ones).\n\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n} // Is the (possibly invalid) x greater than or equal to the (known valid) value?\n// Treat any invalid value as below negative infinity.\n\n\nfunction above(x, value) {\n  return x == null ? false : +x >= value;\n} // During smoothing, treat any invalid value as negative infinity.\n\n\nfunction valid(v) {\n  return v == null || isNaN(v = +v) ? -Infinity : v;\n}\n\nfunction smooth1(x, v0, v1, value) {\n  const a = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);\n  return isNaN(d) ? x : x + d - 0.5;\n}","map":{"version":3,"sources":["/Volumes/Transcend/react/my-portfolio/node_modules/d3-contour/src/contours.js"],"names":["extent","nice","thresholdSturges","ticks","slice","ascending","area","constant","contains","noop","cases","dx","dy","threshold","smooth","smoothLinear","contours","values","tz","Array","isArray","e","finite","length","pop","shift","sort","map","value","contour","v","NaN","isNaN","Error","polygons","holes","isorings","ring","push","forEach","hole","i","n","polygon","type","coordinates","callback","fragmentByStart","fragmentByEnd","x","y","t0","t1","t2","t3","above","stitch","line","start","end","startIndex","index","endIndex","f","g","concat","unshift","point","xt","yt","v1","valid","smooth1","size","_","arguments","_0","Math","floor","_1","thresholds","call","isFinite","Infinity","v0","a","b","d","sign"],"mappings":"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","sourcesContent":["import {extent, nice, thresholdSturges, ticks} from \"d3-array\";\nimport {slice} from \"./array.js\";\nimport ascending from \"./ascending.js\";\nimport area from \"./area.js\";\nimport constant from \"./constant.js\";\nimport contains from \"./contains.js\";\nimport noop from \"./noop.js\";\n\nvar cases = [\n  [],\n  [[[1.0, 1.5], [0.5, 1.0]]],\n  [[[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [0.5, 1.0]]],\n  [[[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 0.5], [1.0, 1.5]]],\n  [[[1.0, 0.5], [0.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 0.5]]],\n  [[[1.0, 1.5], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.5, 1.0]]],\n  [[[1.0, 1.5], [1.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 1.5]]],\n  []\n];\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      const e = extent(values, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1]) tz.pop();\n      while (tz[1] < e[0]) tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    const v = value == null ? NaN : +value;\n    if (isNaN(v)) throw new Error(`invalid value: ${value}`);\n\n    var polygons = [],\n        holes = [];\n\n    isorings(values, v, function(ring) {\n      smooth(ring, values, v);\n      if (area(ring) > 0) polygons.push([ring]);\n      else holes.push(ring);\n    });\n\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array,\n        fragmentByEnd = new Array,\n        x, y, t0, t1, t2, t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = above(values[0], value);\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = above(values[x + 1], value);\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = above(values[y * dx + dx], value);\n      t2 = above(values[y * dx], value);\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);\n        t3 = t2, t2 = above(values[y * dx + x + 1], value);\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = above(values[y * dx + x + 1], value);\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function(point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v1 = valid(values[yt * dx + xt]);\n      if (x > 0 && x < dx && xt === x) {\n        point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);\n      }\n      if (y > 0 && y < dy && yt === y) {\n        point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\n// When computing the extent, ignore infinite values (as well as invalid ones).\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n\n// Is the (possibly invalid) x greater than or equal to the (known valid) value?\n// Treat any invalid value as below negative infinity.\nfunction above(x, value) {\n  return x == null ? false : +x >= value;\n}\n\n// During smoothing, treat any invalid value as negative infinity.\nfunction valid(v) {\n  return v == null || isNaN(v = +v) ? -Infinity : v;\n}\n\nfunction smooth1(x, v0, v1, value) {\n  const a = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);\n  return isNaN(d) ? x : x + d - 0.5;\n}\n"]},"metadata":{},"sourceType":"module"}